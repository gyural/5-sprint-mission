# 객체 직렬화(Serialization)란?

객체 직렬화는 Java 객체를 바이트 스트림(byte stream)으로 변환하는 과정입니다. 이를 통해:

- 객체를 파일에 저장할 수 있습니다.
- 네트워크를 통해 객체를 전송할 수 있습니다.
- 객체를 데이터베이스에 저장할 수 있습니다.

## 직렬화 방법

1. 직렬화하려는 클래스가 `Serializable` 인터페이스를 구현해야 합니다:

```java
import java.io.Serializable;

public class Person implements Serializable {
	private static final long serialVersionUID = 1L;
	// 이하 생략
}
```

- `serialVersionUID` 필드는 직렬화 및 역직렬화를 수행할 때 이 클래스의 버전을 의미해요.
  반드시 필요한 값은 아니지만, 명시적으로 선언하는 것이 좋습니다.
- 만약 역직렬화하려는 클래스의 버전이 기대하는 클래스의 버전과 다르다면 역직렬화에 실패합니다.
- `static`, `long`, 변수명(`serialVersionUID`)은 반드시 지켜야하는 규칙입니다.
  `private`, `final`은 필수는 아니지만 권장사항입니다.

2. `ObjectOutputStream`을 사용하여 객체를 직렬화합니다:

```java
Person person = new Person("김철수", 25);

// 파일에 객체 직렬화하기
try(
FileOutputStream fos = new FileOutputStream("person.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);
){
  oos.

writeObject(person);
}catch(
IOException e){
  e.

printStackTrace();
}
```

- 일반적으로 `.ser` 확장자를 사용합니다.
- `try-with-resource` 구문을 통해 자동으로 리소스를 닫아줍니다.

# 역직렬화(Deserialization)란?

역직렬화는 바이트 스트림을 다시 Java 객체로 변환하는 과정입니다.

## 역직렬화 방법

`ObjectInputStream`을 사용하여 바이트 스트림을 객체로 복원합니다:

```java
try(FileInputStream fis = new FileInputStream("person.ser");
ObjectInputStream ois = new ObjectInputStream(fis)){
Person person = (Person)in.readObject();
}catch(IOException |
ClassNotFoundException e){
  e.

printStackTrace();
}
```

# 주의사항과 고려사항

1. **transient 키워드**

- 특정 필드를 직렬화에서 제외하고 싶을 때 사용합니다:

```java
public class Person implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	private transient String password; // 직렬화에서 제외됨
}

```

1. **serialVersionUID**

- 클래스의 버전 관리를 위해 사용됩니다:

```java
public class Person implements Serializable {
	private static final long serialVersionUID = 1L;
	// 필드들...
}

```

1. **보안 고려사항**

- 직렬화된 데이터는 암호화되지 않습니다
- 민감한 정보는 transient로 표시하거나 암호화해야 합니다

1. **성능 고려사항**

- 직렬화/역직렬화는 리소스를 많이 사용할 수 있습니다
- 대용량 데이터의 경우 JSON이나 Protocol Buffers 같은 대안을 고려해볼 수 있습니다

# 예외 처리

직렬화/역직렬화 과정에서 발생할 수 있는 주요 예외:

- `IOException`: 입출력 작업 중 발생하는 예외
- `ClassNotFoundException`: 역직렬화 시 클래스를 찾을 수 없을 때 발생
- `InvalidClassException`: serialVersionUID가 일치하지 않을 때 발생

# 실제 활용 예제

```java
// Account.java
public class Account implements Serializable {
	private static final long serialVersionUID = 1L;
	private String id;
	private transient String password; // 직렬화에서 제외됨

	public Account(String id, String password) {
		this.id = id;
		this.password = password;
	}

	public String getId() {
		return id;
	}

	public String getPassword() {
		return password;
	}

	@Override
	public String toString() {
		return "Account{" +
		  "id='" + id + '\'' +
		  ", password='" + password + '\'' +
		  '}';
	}
}
```

```java
public class Main {
	public static void init(Path directory) {
		// 저장할 경로의 파일 초기화
		if (!Files.exists(directory)) {
			try {
				Files.createDirectories(directory);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}

	public static <T> void save(Path filePath, T data) {
		try (
		  FileOutputStream fos = new FileOutputStream(filePath.toFile());
		  ObjectOutputStream oos = new ObjectOutputStream(fos);
		) {
			oos.writeObject(data);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	public static <T> List<T> load(Path directory) {
		if (Files.exists(directory)) {
			try {
				List<T> list = Files.list(directory)
				  .map(path -> {
					  try (
						FileInputStream fis = new FileInputStream(path.toFile());
						ObjectInputStream ois = new ObjectInputStream(fis)
					  ) {
						  Object data = ois.readObject();
						  return (T)data;
					  } catch (IOException | ClassNotFoundException e) {
						  throw new RuntimeException(e);
					  }
				  })
				  .toList();
				return list;
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		} else {
			return new ArrayList<>();
		}
	}

	public static void main(String[] args) {
		// 객체 파일을 저장할 디렉토리
		Path directory = Paths.get(System.getProperty("user.dir"), "data");
		// 초기화
		init(directory);
		// 데이터 추가
		List.of(
		  new Account("woody", "woody1234"),
		  new Account("buzz", "buzz5678"),
		  new Account("jessie", "jessie9012")
		).forEach(account -> {
			Path filePath = directory.resolve(account.getId().concat(".ser"));
			save(filePath, account);
		});

		// 데이터 조회
		load(directory)
		  .forEach(data -> System.out.println(data));
	}
}
```